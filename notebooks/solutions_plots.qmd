---
title: "Solutions"
---

# Overview
This script makes some plots from Q10, which is about what solutions participants would find most useful.

# Import packages and utilities
```{r}
project_root <- here::here() # requires that you be somewhere in the
# project directory (not above it)
# packages
suppressMessages(source(file.path(project_root, "scripts/packages.R")))
# functions and objects used across scripts
suppressMessages(source(file.path(project_root, "scripts/utils.R")))
```

# Load data
```{r}
solutions_raw <- load_qualtrics_data("clean_data/solutions_Q10.tsv")
other_quant <- load_qualtrics_data("clean_data/other_quant.tsv")
```

## Wrangle data
First, remove empty rows, i.e. rows from respondents who didn't receive this question. As with many questions in this survey, we can cut some corners in the code because the question was mandatory. For example, no need to worry about incomplete answers.
```{r}
nrow(solutions_raw)
solutions <- exclude_empty_rows(solutions_raw) # from scripts/utils.R
nrow(solutions)
```

Let's reshape the data from wide to long format for easier plotting later.
```{r}
long_data <- solutions %>%
  pivot_longer(
    cols = everything(),
    names_to = "solution",
    values_to = "utility"
  )

long_data <- long_data %>%
  mutate(
    utility_score = recode(
      utility,
      "Non-applicable" = 0L,
      "Not very useful" = 0L,
      "Useful" = 1L,
      "Very useful" = 2L
    )
  )
# Using interger literals 0L, 1L, etc., ensures that
# the new column will be integers, not doubles.

long_data
```

# Descriptive statistics
Next, let's calculate some simple descriptive statistics. I will choose:

- The total "score", that is, the total number of "points" a solution received (see scoring scheme in previous code chunk)
- The mean (which might be misleading if 0s drag it down, and also, who's to say what a 1.5 really means? Are the distances between the Likert points equal? We don't know.)
- The median
- The mode
- The standard deviation
```{r}
# Helper to compute the (numeric) mode
get_mode <- function(x) {
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}

summary_df <- long_data %>%
  group_by(solution) %>%
  summarise(
    total  = sum(utility_score),
    mean   = mean(utility_score, na.rm = TRUE),
    median = median(utility_score),
    mode   = get_mode(utility_score),
    st_dev = sd(utility_score, na.rm = TRUE)
  ) %>%
  ungroup()

# Order by highest total "score"
summary_df <- summary_df %>%
    arrange(desc(total))

summary_df
```

Cool. It looks like sustainability grants are by far the most popular, with assistance identifying funding sources and free computing environments in second and third place. These were the only three solutions that had a mode of 2.

Save for supplement.

```{r}
write_df_to_file(summary_df, "supplementary_tables/solutions_overview.tsv")
```

Out of curiosity, how does it look when we order by variability?
```{r}
summary_df %>%
  arrange(desc(st_dev))
```

This analysis doesn't seem as interesting as it was for the challenges. Industy partnerships, Containerization, and Publicity all show high variance/stdev. These were also somewhat less popular. Come to think of it, the std devs don't vary much.

```{r}
max(summary_df$st_dev)
min(summary_df$st_dev)
max(summary_df$st_dev)-min(summary_df$st_dev)
```

Yeah, the std devs only range from 0.73 to 0.84 (~0.11)--substantially less than the differences in std devs between challenges (~0.66). We could probably demonstrate this with a significance test later if it feels interesting.

Out of curiosity, how many people said they would all be very useful?
```{r}
nrow(
  solutions %>%
    filter(if_all(.cols = everything(), ~ . == "Very useful"))
)
```

Ah, ok. Not that many.

# Plot the distributions
Prepare data for plotting.
```{r}
ordered_levels <- (summary_df %>%
    arrange(desc(total)))$solution

long_data$solution <- factor(long_data$solution, levels = ordered_levels)
```

Grouped bar chart showing the distributions of answers.
```{r, fig.width=9, fig.height=6}
grouped_plot <- grouped_bar_chart(
  df = long_data,
  x_var = "solution",
  fill_var = "utility",
  title = "Preference for various open source solutions"
)

grouped_plot
```

Save the plot if you wish.
```{r}
save_plot("fave_solutions.tiff", 10, 6, p=grouped_plot)
```

# Simple bar plot
Now let's make a simpler bar plot from the next question, which asked participants to choose their favorite solution.
```{r}
favorites <- data.frame(other_quant$favorite_solution)
favorites <- exclude_empty_rows(favorites) # from scripts/utils.R

fav_to_plot <- data.frame(table(favorites[, 1]))
# from scripts/utils.R
fav_to_plot <- reorder_factor_by_column(
  df = fav_to_plot,
  factor_col = Var1,
  value_col = Freq,
  descending = FALSE
)
head(fav_to_plot)
```

```{r, fig.width=9, fig.height=6}
faves_plot <- basic_bar_chart(
  df = fav_to_plot,
  x_var = "Var1",
  y_var = "Freq",
  title = "Experienced contributors' favorite solutions",
  show_axis_title_x = TRUE,
  show_axis_title_y = FALSE,
  ylabel = "Number of Respondents",
  show_bar_labels = TRUE,
  color_index = 7,
  horizontal = TRUE
)

faves_plot
```

The top solutions are not exactly the same in this question compared to tallying up the totals from the previous one, though they are close.

Save the plot if you wish.
```{r}
save_plot("fave_solutions_simple.tiff", 12, 6, p=faves_plot)
```

```{r}
# SVG is higher quality
svglite::svglite(file.path(FIGURE_PATH, "fave_solutions_simple.svg"), width = 13, height = 6.5); print(faves_plot); dev.off()
```

Save the data to file for tweaking the final figure. 

```{r}
write_df_to_file(fav_to_plot, "data_for_plots/exp_fave_solns.tsv")
```

# Incorporating demographics

## Plots

Who are these people who want access to computing environments? Don't all the UCs already offer this?

Let's focus on job category. 
```{r}
campus_job_fave <- other_quant %>%
  select(campus, job_category, favorite_solution)
campus_job_fave <- exclude_empty_rows(campus_job_fave, strict = TRUE)

# For visual clarity, let's combine postdocs and other staff researchers.
campus_job_fave <- campus_job_fave %>%
  mutate(
    job_category = recode(
      job_category,
      "Post-Doc" = "Postdocs and\nStaff Researchers",
      "Other research staff" = "Postdocs and\nStaff Researchers"
    )
  )

head(campus_job_fave)
```

Of the people who selected "Computing environments", what is the distribution of job categories?
```{r}
compute <- campus_job_fave %>%
  filter(favorite_solution == "Computing environments")
compute_counts <- data.frame(table(compute$job_category))

compute_counts <- compute_counts %>% rename(job_category = Var1, compute = Freq)

compute_counts <- reorder_factor_by_column(
  df = compute_counts,
  factor_col = job_category,
  value_col = compute
)
```

```{r, fig.width=10, fig.height=8}
compute_bar <- basic_bar_chart(
  df = compute_counts,
  x_var = "job_category",
  y_var = "compute",
  title = "Respondents whose top choice was\n'Access to free, feature-rich computing environments'",
  color_index = 4,
  show_bar_labels = TRUE
)
compute_bar
```

Save the plot if you wish.
```{r}
save_plot("compute_job.tiff", 10, 10, p=compute_bar)
```

So those are the absolute numbers, but they don't normalize for the sample sizes of the different job categories. The number of non-research staff who voted for computing environments might be high because there are simply a lot of non-research staff in our survey.
```{r}
total_counts <- data.frame(table(campus_job_fave$job_category))

total_counts <- total_counts %>% rename(job_category = Var1, total = Freq)

proportion_df <- compute_counts %>%
  left_join(total_counts, by = "job_category") %>%
  mutate(proportion = round(compute / total, 2))

proportion_df
```

The previous plot suggested the demand was mostly coming from non-research staff, but that was deceiving, because we do indeed have a lot of non-research staff in our sample. Let's make a plot that is, I think, more informative. This plot shows the percent of people in that job category who selected computing environments as their favorite solution.
```{r, fig.width=10, fig.height=8}
compute_bar_prop <- basic_bar_chart(
  df = proportion_df,
  x_var = "job_category",
  y_var = "proportion",
  ylabel = "Percent of Job Category who Selected this Option",
  title = "Respondents whose top choice was\n'Access to free, feature-rich computing environments'",
  color_index = 4,
  show_bar_labels = TRUE,
  percent = TRUE
)
compute_bar_prop
```

Save the plot if you wish.
```{r}
save_plot("compute_job_prop.tiff", 10, 10, p=compute_bar_prop)
```

Let's make the same plot, but this time with campus info.

```{r}
compute_counts2 <- compute %>%
  select(-favorite_solution) %>%
  count(
    campus,
    job_category,
    name = "count"
  )

compute_counts2$job_category <- factor(
  compute_counts2$job_category,
  levels = levels(compute_counts$job_category)
)
```

```{r, fig.width=11, fig.height=11}
compute_campus_bar <- stacked_bar_chart(
  df = compute_counts2,
  x_var = "job_category",
  y_var = "count",
  fill = "campus",
  title = "Respondents who wanted\n'Access to free, feature-rich computing environments'",
  ylabel = NULL,
  proportional = FALSE
)

compute_campus_bar
```

This one is a bit harder to interpret, because it's a busy plot and the sample sizes are small. Anyway, save the plot if you wish.
```{r}
save_plot("compute_job_campus.tiff", 14, 14, p=compute_campus_bar)
```


## Response rates by campus, for "Compute environments"

I'm wondering if there's one or two campuses in particular where compute environments are lacking. 
```{r}
compute_counts_campus <- campus_job_fave %>%
  filter(favorite_solution == "Computing environments") %>%
  count(campus, name = "compute_n")

# a scalar
total_compute_votes <- nrow(campus_job_fave %>%
  filter(favorite_solution == "Computing environments"))
```
```{r}
campus_totals <- campus_job_fave %>%
  count(campus, name = "campus_total")

campus_totals <- left_join(campus_totals, compute_counts_campus, by="campus")
campus_totals <- exclude_empty_rows(campus_totals, strict=TRUE)

campus_totals %>% mutate( compute_perc = 100*compute_n / campus_total)
```

So, anywhere from 12% to 33% of respondents selected this as their favorite solution, when we break it down by campus. The numbers from UCSD (33%) and UC Merced (25%) should probably be taken with a grain of salt, since those campuses had really low participation rates.

## For each job category, what are the top 5 favorite solutions?

### From the "choose one" question

First, calculate the result based on Q11, the "choose one" question, where participants had to choose their favorite solution.

```{r}
job_fave <- campus_job_fave %>% select(-campus)
#Reorder factor levels for plotting
job_fave$job_category <- factor(job_fave$job_category, levels = c(
  "Faculty",
  "Postdocs and\nStaff Researchers",
  "Grad Student",
  "Undergraduate",
  "Non-research Staff"
))

job_fave_counts <- job_fave %>%
  count(
    job_category,
    favorite_solution,
    name = "count"
  )

# 2) For each job_category, keep only the top 5 solutions by count
top_solutions <- job_fave_counts %>%
  group_by(job_category) %>%
  # slice_max() picks the rows with the highest `count`
  slice_max(order_by = count, n = 5, with_ties = TRUE) %>%
  ungroup()

top_solutions
```

This looks like it's worth plotting. Let's go back to the big data frame, since my grouped_bar_chart function doesn't want counts (it will count rows itself); drop all job/solution combinations except those that appear in the top_solutions data frame.
```{r}
job_fave_top <- job_fave %>%
  semi_join(
    top_solutions,
    by = c("job_category", "favorite_solution")
  )

head(job_fave_top)
```

```{r}
# Reorder factor levels so legend items are in order of appearance
job_fave_top <- job_fave_top %>%
  mutate(favorite_solution = fct_inorder(favorite_solution))
```

```{r, fig.width=9, fig.height=6}
top_plot <- grouped_bar_chart(
  df = job_fave_top,
  x_var = "job_category",
  fill_var = "favorite_solution",
  title = "Top 5 Solutions by Job Category ('choose one')",
  color_palette = rev(c(COLORS, "#000000")) #from utils.R
)
top_plot
```

```{r}
save_plot("top_solutions_by_job.tiff", 12, 10, p=top_plot)
```

### Likert points

Now we ask the same question (top 5 per job category), but we get the result by tallying up the Likert scale  "points" from Q10.

```{r}
solutions_job_raw <- cbind(solutions_raw, other_quant$job_category)
# Rename last column
names(solutions_job_raw)[ncol(solutions_job_raw)] <- "job_category"
```

Remove rows that contain any empty entries.
```{r}
nrow(solutions_job_raw)
solutions_job <- exclude_empty_rows(solutions_job_raw, strict = TRUE) # from scripts/utils.R
nrow(solutions_job)
```

For visual clarity in our plots, let's combine postdocs and other staff researchers, as well as undergrads and grad students.
```{r}
solutions_job <- solutions_job %>%
  mutate(
    job_category = recode(
      job_category,
      "Post-Doc" = "Postdocs and Staff Researchers",
      "Other research staff" = "Postdocs and Staff Researchers"
    )
  )

solutions_job <- solutions_job %>%
  mutate(
    job_category = recode(
      job_category,
      "Grad Student" = "Students",
      "Undergraduate" = "Students"
    )
  )

solutions_job$participantID <- row.names(solutions_job)

head(solutions_job)
```

Let's reshape the data from wide to long format for easier counting and plotting.

```{r}
long_data_job <- solutions_job %>%
  pivot_longer(
    cols = -c(participantID, job_category),
    names_to = "solution",
    values_to = "utility"
  )

long_data_job <- long_data_job %>%
  mutate(
    utility_score = recode(
      utility,
      "Non-applicable" = 0L,
      "Not very useful" = 0L,
      "Useful" = 1L,
      "Very useful" = 2L
    )
  )

long_data_job
```

Modifying some code I copied from challenges_plus_job.qmd.

```{r}
get_summary_df <- function(job_str, df) {
  res <- df %>%
    filter(job_category == job_str) %>%
    group_by(solution) %>%
    summarise(
      total = sum(utility_score),
      mean = mean(utility_score, na.rm = TRUE)
    ) %>%
    ungroup() %>%
    arrange(desc(total))
  return(res)
}
```

```{r}
jobs_ordered <- c(
  "Faculty",
  "Postdocs and Staff Researchers",
  "Students",
  "Non-research Staff"
)

summary_tables <- lapply(jobs_ordered, function(j) get_summary_df(j, long_data_job))
names(summary_tables) <- jobs_ordered
summary_tables
```

Let's plot the top 5. First, a little data wrangling.

```{r}
all_tbl <- bind_rows(summary_tables, .id = "job_category")

top_by_job_points <- all_tbl %>%
  group_by(job_category) %>%
  slice_max(mean, n = 5, with_ties = FALSE) %>%
  ungroup() %>%
  select(job_category, solution, mean) %>%
  mutate(job_category = factor(job_category, levels = jobs_ordered))

# Reorder factor levels for visual clarity

ordered_solns_top_by_points <- c(
  "Sustainability grants",
  "Help finding funding",
  "Computing environments",
  "Industry partnerships",
  "Publicity",
  "Documentation help",
  "Legal support",
  "A learning community",
  "Mentoring programs"
)                                                

top_by_job_points$solution <- factor(
  top_by_job_points$solution,
  levels = ordered_solns_top_by_points
)
```

Let's add a whitespace in this long job category name

```{r}
top_by_job_points <- top_by_job_points %>%
  mutate(
    job_category = recode(
      job_category,
      "Postdocs and Staff Researchers" = "Postdocs and\nStaff Researchers",
    )
  )
```

Let's hard-code a color palette that is tailored to these data. This will be useful in the next section, when we plot almost the same set of challenges, and we'll want the challenges to correspond to the same colors in the legend.
```{r}
# I'm just including the names here for my own reference,
# but they're not actually used in the code.
# chall_colors <- list(
#   # modified from https://sronpersonalpages.nl/~pault/
#   "Documentation time" = "#332288",
#   "Coding time" = "#88CCEE",
#   "Education time" = "#44AA99",
#   "Educational resources" = "#117733",
#   "Securing funding" = "#999933",
#   "Finding funding" = "#DDCC77",
#   "Managing issues" = "#CC6677",
#   "Attracting users" = "#882255"
# )
```

```{r, fig.width=9, fig.height=6}
top_points_plot <- ggplot(
  top_by_job_points,
  aes(
    x = job_category,
    y = mean,
    fill = solution
  )
) +
  geom_col(position = position_dodge()) +
  scale_fill_manual(values = COLORS) +
  labs(
    x = "Job Category",
    y = "Mean Observed Rating\nFrom Coded Categories",
    fill = "Solution",
    title = "Top 5 Solutions by Job Category (Points)"
  ) +
  theme(
    axis.title.x = element_blank(),
    axis.title.y = element_text(size = 24),
    axis.text.x = element_text(angle = 60, vjust = 0.6, size = 18),
    axis.text.y = element_text(size = 18),
    axis.ticks.x = element_blank(),
    legend.title = element_blank(),
    legend.text = element_text(size = 18),
    panel.background = element_blank(),
    panel.grid = element_line(linetype = "solid", color = "gray90"),
    plot.title = element_text(hjust = 0.5, size = 24),
    plot.margin = unit(c(0.3, 0.3, 0.3, 0.3), "cm")
  )
top_points_plot
```

```{r}
save_plot("top5_solutions_by_job_points.tiff", 12, 10, p=top_points_plot)
```

### Proportion useful or very useful

As another way of confirming/exploring these trends, let's look at the proportion of each group who said "useful" or "very useful".
```{r}
# Calculate proportion of TRUEs by taking the mean of a logical vector,
# created by %in%.
proportions <- long_data_job %>%
  group_by(job_category, solution) %>%
  summarize(proportion = mean(utility %in% c("Useful", "Very useful"))) %>%
  ungroup()
proportions
```

```{r}
top_by_prop <- proportions %>%
  group_by(job_category) %>%
  slice_max(order_by = proportion, n = 5)
```

```{r}
# Filter to include only challenges present in the top n dataframe 
filtered_props <- proportions %>%
  semi_join(top_by_prop, by = c("job_category", "solution"))
```

```{r}
# Reorder factor levels
filtered_props$solution <- factor(
  filtered_props$solution,
  levels = ordered_solns_top_by_points
)

filtered_props$job_category <- factor(
  filtered_props$job_category,
  levels = jobs_ordered
)
```


Let's add a whitespace in this long job category name

```{r}
filtered_props <- filtered_props %>%
  mutate(
    job_category = recode(
      job_category,
      "Postdocs and Staff Researchers" = "Postdocs and\nStaff Researchers",
    )
  )
```


```{r, fig.width=9, fig.height=6}
top_perc_plot <- ggplot(
  filtered_props,
  aes(
    x = job_category,
    y = proportion,
    fill = solution
  )
) +
  geom_col(position = position_dodge()) +
  scale_y_continuous(labels = scales::percent, limits = c(0, 1)) +
  scale_fill_manual(values = COLORS) +
  labs(
    x = "Job Category",
    y = "Proportion saying\n'Useful' or 'Very useful'",
    fill = "Challenge",
    title = "Top 5 Solutions by Job Category (Percent)"
  ) +
  theme(
    axis.title.x = element_blank(),
    axis.title.y = element_text(size = 24),
    axis.text.x = element_text(angle = 60, vjust = 0.6, size = 18),
    axis.text.y = element_text(size = 18),
    axis.ticks.x = element_blank(),
    legend.title = element_blank(),
    legend.text = element_text(size = 18),
    panel.background = element_blank(),
    panel.grid = element_line(linetype = "solid", color = "gray90"),
    plot.title = element_text(hjust = 0.5, size = 24),
    plot.margin = unit(c(0.3, 0.3, 0.3, 0.3), "cm")
  )
top_perc_plot
```

```{r}
save_plot("top5_solns_by_job_percent.tiff", 12, 10, p=top_perc_plot)
```



# A Learning Community
Let's make a plot similar to the one before, where we plotted the percent of folks in each job category who selected "computing environments" as their favorite solution. This time, though, we'll look at "A learning community".

```{r}
learn <- campus_job_fave %>%
  filter(favorite_solution == "A learning community")
learn_counts <- data.frame(table(learn$job_category))

learn_counts <- learn_counts %>% rename(job_category = Var1, learning = Freq)

learn_counts <- reorder_factor_by_column(
  df = learn_counts,
  factor_col = job_category,
  value_col = learning
)
```

```{r}
total_counts <- data.frame(table(campus_job_fave$job_category))

total_counts <- total_counts %>% rename(job_category = Var1, total = Freq)

proportion_df2 <- learn_counts %>%
  left_join(total_counts, by = "job_category") %>%
  mutate(proportion = round(learning / total, 2))

proportion_df2
```

```{r, fig.width=10, fig.height=8}
learn_bar_prop <- basic_bar_chart(
  df = proportion_df2,
  x_var = "job_category",
  y_var = "proportion",
  ylabel = "Percent of Job Category who Selected this Option",
  title = "Respondents whose top choice was\n'A learning community'",
  color_index = 4,
  show_bar_labels = TRUE,
  percent = TRUE
)
learn_bar_prop
```

```{r}
save_plot("learn_job_prop.tiff", 12, 10, p=learn_bar_prop)
```

# Sustainability grants
Same thing, but now with sustainability grants.

```{r}
grants <- campus_job_fave %>%
  filter(favorite_solution == "Sustainability grants")
grants_counts <- data.frame(table(grants$job_category))

grants_counts <- grants_counts %>% rename(job_category = Var1, grants = Freq)

grants_counts <- reorder_factor_by_column(
  df = grants_counts,
  factor_col = job_category,
  value_col = grants
)
```

```{r}
total_counts <- data.frame(table(campus_job_fave$job_category))

total_counts <- total_counts %>% rename(job_category = Var1, total = Freq)

proportion_df3 <- grants_counts %>%
  left_join(total_counts, by = "job_category") %>%
  mutate(proportion = round(grants / total, 2))

proportion_df3
```

```{r, fig.width=10, fig.height=8}
grants_bar_prop <- basic_bar_chart(
  df = proportion_df3,
  x_var = "job_category",
  y_var = "proportion",
  ylabel = "Percent of Job Category who Selected this Option",
  title = "Respondents whose top choice was\n'Sustainability grants'",
  color_index = 4,
  show_bar_labels = TRUE,
  percent = TRUE
)
grants_bar_prop
```

```{r}
save_plot("grants_job_prop.tiff", 12, 10, p=grants_bar_prop)
```


# Session Info
```{r}
sessionInfo()
```